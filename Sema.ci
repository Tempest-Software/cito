// Sema.ci - semantic analysis of Ci
//
// Copyright (C) 2011-2022  Piotr Fusik
//
// This file is part of CiTo, see https://github.com/pfusik/cito
//
// CiTo is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// CiTo is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with CiTo.  If not, see http://www.gnu.org/licenses/

public abstract class CiSema : CiVisitor
{
	protected CiProgram Program;
	protected CiScope! CurrentScope;
	protected CiType# Poison = new CiType { Name = "poison" };

	protected override CiContainerType GetCurrentContainer() => this.CurrentScope.GetContainer();

	protected CiType# PoisonError!(CiStatement statement, string message)
	{
		ReportError(statement, message);
		return this.Poison;
	}

	protected static void TakePtr(CiExpr expr)
	{
		if (expr.Type is CiArrayStorageType! arrayStg)
			arrayStg.PtrTaken = true;
	}

	protected bool Coerce!(CiExpr expr, CiType type)
	{
		if (expr == this.Poison)
			return false;
		if (!type.IsAssignableFrom(expr.Type)) {
			ReportError(expr, $"Cannot coerce {expr.Type} to {type}");
			return false;
		}
		if (expr is CiPrefixExpr prefix && prefix.Op == CiToken.New && !(type is CiDynamicPtrType)) {
			assert expr.Type is CiDynamicPtrType newType;
			string kind = newType.Class.Id == CiId.ArrayPtrClass ? "array" : "object";
			ReportError(expr, $"Dynamically allocated {kind} must be assigned to a {expr.Type} reference");
			return false;
		}
		TakePtr(expr);
		return true;
	}

	void VisitAggregateInitializer(CiAggregateInitializer expr)
	{
		List<CiExpr#>! items = expr.Items;
		for (int i = 0; i < items.Count; i++)
			items[i] = Resolve(items[i]);
	}

	protected static CiRangeType# Union(CiRangeType# left, CiRangeType# right)
	{
		if (right == null)
			return left;
		if (right.Min < left.Min) {
			if (right.Max >= left.Max)
				return right;
			return CiRangeType.New(right.Min, left.Max);
		}
		if (right.Max > left.Max)
			return CiRangeType.New(left.Min, right.Max);
		return left;
	}

	CiType# TryGetPtr(CiType# type)
	{
		if (type.Id == CiId.StringStorageType)
			return this.Program.System.StringPtrType;
		if (type is CiStorageType storage)
			return new CiReadWriteClassType { Class = storage.Class.Id == CiId.ArrayStorageClass ? this.Program.System.ArrayPtrClass : storage.Class, TypeArg0 = storage.TypeArg0, TypeArg1 = storage.TypeArg1 };
		return type;
	}

	protected CiType# GetCommonType!(CiExpr left, CiExpr right)
	{
		if (left.Type is CiRangeType# leftRange && right.Type is CiRangeType# rightRange)
			return Union(leftRange, rightRange);
		CiType# ptr = TryGetPtr(left.Type);
		if (ptr.IsAssignableFrom(right.Type))
			return ptr;
		ptr = TryGetPtr(right.Type);
		if (ptr.IsAssignableFrom(left.Type))
			return ptr;
		return PoisonError(left, $"Incompatible types: {left.Type} and {right.Type}");
	}

	protected CiType# GetIntegerType!(CiExpr left, CiExpr right)
	{
		CiType# type = this.Program.System.PromoteIntegerTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	protected CiIntegerType# GetShiftType!(CiExpr left, CiExpr right)
	{
		CiIntegerType# intType = this.Program.System.IntType;
		Coerce(right, intType);
		if (left.Type.Id == CiId.LongType) {
			assert left.Type is CiIntegerType# longType;
			return longType;
		}
		Coerce(left, intType);
		return intType;
	}

	protected CiType# GetNumericType!(CiExpr left, CiExpr right)
	{
		CiType# type = this.Program.System.PromoteNumericTypes(left.Type, right.Type);
		Coerce(left, type);
		Coerce(right, type);
		return type;
	}

	protected static int SaturatedShiftRight(int a, int b) => a >> (b >= 31 || b < 0 ? 31 : b);

	protected static CiRangeType# UnsignedAnd(CiRangeType left, CiRangeType right)
	{
		int leftVariableBits = left.GetVariableBits();
		int rightVariableBits = right.GetVariableBits();
		int min = left.Min & right.Min & ~CiRangeType.GetMask(~left.Min & ~right.Min & (leftVariableBits | rightVariableBits));
		// Calculate upper bound with variable bits set
		int max = (left.Max | leftVariableBits) & (right.Max | rightVariableBits);
		// The upper bound will never exceed the input
		if (max > left.Max)
			max = left.Max;
		if (max > right.Max)
			max = right.Max;
		if (min > max)
			return CiRangeType.New(max, min); // FIXME: this is wrong! e.g. min=0 max=0x8000000_00000000 then 5 should be in range
		return CiRangeType.New(min, max);
	}

	protected static CiRangeType# UnsignedOr(CiRangeType left, CiRangeType right)
	{
		int leftVariableBits = left.GetVariableBits();
		int rightVariableBits = right.GetVariableBits();
		int min = (left.Min & ~leftVariableBits) | (right.Min & ~rightVariableBits);
		int max = left.Max | right.Max | CiRangeType.GetMask(left.Max & right.Max & CiRangeType.GetMask(leftVariableBits | rightVariableBits));
		// The lower bound will never be less than the input
		if (min < left.Min)
			min = left.Min;
		if (min < right.Min)
			min = right.Min;
		if (min > max)
			return CiRangeType.New(max, min); // FIXME: this is wrong! e.g. min=0 max=0x8000000_00000000 then 5 should be in range
		return CiRangeType.New(min, max);
	}

	protected static CiRangeType# UnsignedXor(CiRangeType left, CiRangeType right)
	{
		int variableBits = left.GetVariableBits() | right.GetVariableBits();
		int min = (left.Min ^ right.Min) & ~variableBits;
		int max = (left.Max ^ right.Max) | variableBits;
		if (min > max)
			return CiRangeType.New(max, min); // FIXME: this is wrong! e.g. min=0 max=0x8000000_00000000 then 5 should be in range
		return CiRangeType.New(min, max);
	}

	protected static CiRangeType# NewRangeType(int a, int b, int c, int d)
	{
		if (a > b) {
			int t = a;
			a = b;
			b = t;
		}
		if (c > d) {
			int t = c;
			c = d;
			d = t;
		}
		return CiRangeType.New(a <= c ? a : c, b >= d ? b : d);
	}

	protected bool IsEnumOp!(CiExpr left, CiExpr right)
	{
		if (left.Type is CiEnum) {
			if (left.Type.Id != CiId.BoolType && !(left.Type is CiEnumFlags))
				ReportError(left, $"Define flags enumeration as: enum* {left.Type}");
			Coerce(right, left.Type);
			return true;
		}
		return false;
	}

	protected CiLiteralLong# ToLiteralLong(CiExpr expr, long value) => this.Program.System.NewLiteralLong(value, expr.Line);

	protected CiLiteralDouble# ToLiteralDouble(CiExpr expr, double value) => new CiLiteralDouble { Line = expr.Line, Type = this.Program.System.DoubleType, Value = value };

	protected void CheckLValue(CiExpr expr)
	{
		// TODO: check lvalue
		if (expr is CiSymbolReference symbol) {
			if (symbol.Symbol is CiVar! def) {
				def.IsAssigned = true;
				switch (symbol.Symbol.Parent) {
				case CiFor forLoop:
					forLoop.IsRange = false;
					break;
				case CiForeach _:
					ReportError(expr, "Cannot assign a foreach iteration variable");
					break;
				default:
					break;
				}
			}
			for (CiScope! scope = this.CurrentScope; !(scope is CiClass); scope = scope.Parent) {
				if (scope is CiFor! forLoop
				 && forLoop.IsRange
				 && forLoop.Cond is CiBinaryExpr binaryCond
				 && binaryCond.Right.IsReferenceTo(symbol.Symbol))
					forLoop.IsRange = false;
			}
		}
	}

	protected CiInterpolatedString# ToInterpolatedString(CiExpr# expr)
	{
		if (expr is CiInterpolatedString# interpolated)
			return interpolated;
		CiInterpolatedString# result = new CiInterpolatedString { Line = expr.Line, Type = this.Program.System.StringStorageType };
		if (expr is CiLiteral literal)
			result.Suffix = literal.GetLiteralString();
		else {
			result.AddPart("", expr);
			result.Suffix = "";
		}
		return result;
	}

	protected void CheckComparison!(CiExpr left, CiExpr right)
	{
		CiType doubleType = this.Program.System.DoubleType;
		Coerce(left, doubleType);
		Coerce(right, doubleType);
	}

	protected CiType# EvalType(CiClassType generic, CiType# type)
	{
		if (type.Id == CiId.TypeParam0)
			return generic.TypeArg0;
		if (type.Id == CiId.TypeParam0NotFinal)
			return generic.TypeArg0.IsFinal() ? null : generic.TypeArg0;
		if (type is CiReadWriteClassType array && array.IsArray() && array.GetElementType().Id == CiId.TypeParam0)
			return new CiReadWriteClassType { Class = this.Program.System.ArrayPtrClass, TypeArg0 = generic.TypeArg0 };
		return type;
	}

	protected bool CanCall(CiExpr obj, CiMethod method, List<CiExpr> arguments)
	{
		CiVar param = method.Parameters.FirstParameter();
		foreach (CiExpr arg in arguments) {
			if (param == null)
				return false;
			CiType# type = param.Type;
			if (obj != null && obj.Type is CiClassType generic)
				type = EvalType(generic, type);
			if (!type.IsAssignableFrom(arg.Type))
				return false;
			param = param.NextParameter();
		}
		return param == null || param.Value != null;
	}

	protected void OpenScope!(CiScope! scope)
	{
		scope.Parent = this.CurrentScope;
		this.CurrentScope = scope;
	}

	protected void CloseScope!()
	{
		this.CurrentScope = this.CurrentScope.Parent;
	}

	protected abstract CiExpr# VisitInterpolatedString!(CiInterpolatedString# expr);

	protected abstract CiExpr# VisitSymbolReference!(CiSymbolReference# expr);

	protected abstract CiExpr# VisitPrefixExpr!(CiPrefixExpr# expr);

	void VisitPostfixExpr!(CiPostfixExpr! expr)
	{
		expr.Inner = Resolve(expr.Inner);
		switch (expr.Op) {
		case CiToken.Increment:
		case CiToken.Decrement:
			CheckLValue(expr.Inner);
			Coerce(expr.Inner, this.Program.System.DoubleType);
			expr.Type = expr.Inner.Type;
			break;
		default:
			ReportError(expr, $"Unexpected {CiLexer.TokenToString(expr.Op)}");
			break;
		}
	}

	protected abstract CiExpr# VisitBinaryExpr!(CiBinaryExpr# expr);

	CiExpr# VisitSelectExpr!(CiSelectExpr expr)
	{
		CiExpr# cond = ResolveBool(expr.Cond);
		CiExpr# onTrue = Resolve(expr.OnTrue);
		CiExpr# onFalse = Resolve(expr.OnFalse);
		CiType# type = GetCommonType(onTrue, onFalse);
		Coerce(onTrue, type);
		Coerce(onFalse, type);
		if (cond is CiLiteralTrue)
			return onTrue;
		if (cond is CiLiteralFalse)
			return onFalse;
		return new CiSelectExpr { Line = expr.Line, Cond = cond, OnTrue = onTrue, OnFalse = onFalse, Type = type };
	}

	protected abstract CiExpr# VisitCallExpr!(CiCallExpr# expr);

	protected abstract void VisitVar(CiVar! expr);

	protected CiExpr# Resolve(CiExpr# expr)
	{
		switch (expr) {
		case CiAggregateInitializer aggregate:
			VisitAggregateInitializer(aggregate);
			return expr;
		case CiLiteral _:
			return expr;
		case CiInterpolatedString# interpolated:
			return VisitInterpolatedString(interpolated);
		case CiSymbolReference# symbol:
			return VisitSymbolReference(symbol);
		case CiPrefixExpr# prefix:
			return VisitPrefixExpr(prefix);
		case CiPostfixExpr! postfix:
			VisitPostfixExpr(postfix);
			return expr;
		case CiBinaryExpr# binary:
			return VisitBinaryExpr(binary);
		case CiSelectExpr select:
			return VisitSelectExpr(select);
		case CiCallExpr# call:
			return VisitCallExpr(call);
		case CiLambdaExpr _:
			ReportError(expr, "Unexpected lambda expression");
			return expr;
		case CiVar! def:
			VisitVar(def);
			return expr;
		default:
			assert false;
		}
	}

	public override void VisitExpr(CiExpr# statement)
	{
		Resolve(statement);
	}

	protected CiExpr# ResolveBool(CiExpr# expr)
	{
		expr = Resolve(expr);
		Coerce(expr, this.Program.System.BoolType);
		return expr;
	}

	protected bool ResolveStatements!(List<CiStatement> statements)
	{
		bool reachable = true;
		foreach (CiStatement statement in statements) {
			statement.AcceptStatement(this);
			if (!reachable) {
				ReportError(statement, "Unreachable statement");
				return false;
			}
			reachable = statement.CompletesNormally();
		}
		return reachable;
	}

	public override void VisitBlock!(CiBlock! statement)
	{
		OpenScope(statement);
		statement.SetCompletesNormally(ResolveStatements(statement.Statements));
		CloseScope();
	}

	public override void VisitBreak(CiBreak statement)
	{
		statement.LoopOrSwitch.SetCompletesNormally(true);
	}

	public override void VisitContinue(CiContinue statement)
	{
	}

	public override void VisitNative(CiNative statement)
	{
	}

	protected void ExpectNoPtrModifier!(CiExpr expr, CiToken ptrModifier)
	{
		if (ptrModifier != CiToken.EndOfFile)
			ReportError(expr, $"Unexpected {CiLexer.TokenToString(ptrModifier)} on a non-reference type");
	}

	protected CiExpr# FoldConst(CiExpr# expr)
	{
		expr = Resolve(expr);
		if (expr is CiLiteral || expr.IsConstEnum())
			return expr;
		ReportError(expr, "Expected constant value");
		return expr;
	}

	protected static CiClassType# CreateClassPtr(CiClass klass, CiToken ptrModifier)
	{
		CiClassType# ptr;
		switch (ptrModifier) {
		case CiToken.EndOfFile:
			ptr = new CiClassType();
			break;
		case CiToken.ExclamationMark:
			ptr = new CiReadWriteClassType();
			break;
		case CiToken.Hash:
			ptr = new CiDynamicPtrType();
			break;
		default:
			assert false;
		}
		ptr.Class = klass;
		return ptr;
	}

	static void MarkMethodLive(CiMethodBase! method)
	{
		if (method.IsLive)
			return;
		method.IsLive = true;
		foreach (CiMethod! called in method.Calls)
			MarkMethodLive(called);
	}

	protected static void MarkClassLive(CiClass klass)
	{
		if (!klass.IsPublic)
			return;
		for (CiSymbol! symbol = klass.First; symbol != null; symbol = symbol.Next) {
			if (symbol is CiMethod! method
			 && (method.Visibility == CiVisibility.Public || method.Visibility == CiVisibility.Protected))
				MarkMethodLive(method);
		}
		if (klass.Constructor != null)
			MarkMethodLive(klass.Constructor);
	}
}
